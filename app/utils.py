import re
import ast
import json
import logging

def flatten_dict(d, parent_key='', sep='/'):
    """Recursively flattens nested dictionaries."""
    items = []
    for k, v in d.items():
        new_key = f"{parent_key}{sep}{k}" if parent_key else k
        if isinstance(v, dict):
            items.extend(flatten_dict(v, new_key, sep=sep).items())
        else:
            items.append((new_key, v))
    return dict(items)

def generate_default_readme(file_structure):
    """Creates a fallback README if the AI forgets one."""
    files_list = "\n".join([f"- `{f}`" for f in file_structure.keys()])
    return f"""# AI Generated Project

## ðŸ“‚ Project Structure
{files_list}

## ðŸš€ Getting Started
1. Install dependencies (if requirements.txt exists).
2. Run the main script (usually main.py or app.py).

*Generated by AI Folder Builder*
"""

def parse_ai_response(response_text: str) -> dict:
    """
    Robust parser: Handles Markdown, JSON, Python Dicts, Nested Structures,
    AND ensures a README.md always exists.
    """
    data = {}
    
    # 1. Parsing Logic
    try:
        if isinstance(response_text, dict):
            data = response_text
        else:
            # Clean Markdown
            clean_text = re.sub(r"^```[a-zA-Z]*\n", "", response_text.strip())
            clean_text = re.sub(r"\n```$", "", clean_text)
            
            # Find JSON/Dict
            match = re.search(r"(\{.*\})", clean_text, re.DOTALL)
            if match:
                json_str = match.group(1)
                try:
                    data = json.loads(json_str)
                except:
                    try:
                        data = ast.literal_eval(json_str)
                    except:
                        pass
    except Exception as e:
        logging.error(f"Parsing Error: {e}")

    # 2. Flattening Logic (Fixes nested folder errors)
    if isinstance(data, dict) and data:
        data = flatten_dict(data)
    else:
        # If parsing failed completely, return empty
        return {}

    # 3. AUTO-INJECT README (The Fix)
    # Check if README.md exists (case-insensitive)
    readme_exists = any(k.lower() == 'readme.md' for k in data.keys())
    
    if not readme_exists:
        # Create a dynamic README based on the files we found
        data['README.md'] = generate_default_readme(data)

    return data